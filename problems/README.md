# Implementation required

## ARRAYS Part 1

- [ ] Set Matrix Zeros
- [ ] Pascal's Triangle
- [ ] Next Permutation
- [ ] Kadane's Algorithm
- [ ] Sort and array of 0's 1's 2's
- [ ] Stock buy and Sell

## ARRAYS Part 2

- [ ] Rotate Matrix
- [ ] Merge Overlapping Subintervals
- [ ] Merge Two sorted Arrays without extra space
- [ ] Find the duplicate in an array of N + 1 integers
- [ ] Repeat and Missing Number
- [ ] Inversion of Array (Pre-req: Merge Sort)

## ARRAYS Part 3

- [ ] Search in a 2d Matrix
- [ ] Pow(X, n)
- [ ] Majority Element (>N/2 times)
- [ ] Majority Element (>N/3 times)
- [ ] Grid Unique Paths
- [ ] Reverse Pairs (Leetcode)

## ARRAYS Part 4

- [ ] 2-Sum Problem
- [ ] 4-Sum Problem
- [ ] Longest Consecutive Sequence
- [ ] Largest Subarray with 0 sum
- [ ] Count number of subarrays with given Xor K
- [ ] Longest Substring without repeat

## LINKED LIST Part 1

- [ ] Reverse a LinkedList
- [ ] Find the middle of LinkedList
- [ ] Merge two sorted Linked List (use method used in mergeSort)
- [ ] Remove N-th node from back of LinkedList
- [ ] Add two numbers as LinkedList
- [ ] Delete a given Node when a node is given (O(1) Solution)

## LINKED LIST Part 2

- [ ] Find intersection point of Y LinkedList
- [ ] Detect a cycle in Linked List
- [ ] Reverse a LinkedList in groups of size k.
- [ ] Check if a LinkedList is palindrome or not.
- [ ] Find the starting point of the loop of LinkedList
- [ ] Flattening of a LinkedList

## LINKED LIST AND ARRAYS

- [ ] Rotate a Linked List
- [ ] Clone a Linked List with random and next pointer
- [ ] 3 sum
- [ ] Trapping rainwater
- [ ] Remove Duplicate from Sorted array
- [ ] Max Consecutive ones

## GREEDY ALGORITHMS

- [ ] N meetings in one room
- [ ] Minimum number of platforms required for a railway
- [ ] Job Sequencing Problem
- [ ] Fractional Knapsack Problem
- [ ] Greedy algorithm to find minimum number of coins
- [ ] Activity Selection

## RECURSION

- [ ] Subset Sums
- [ ] Subset II
- [ ] Combination Sum I
- [ ] Combination Sum II
- [ ] Palindrome Partitioning
- [ ] Kth Permutation Sequence

## RECURSION AND BACKTRACKING

- [ ] Print all permuatations of a string/array
- [ ] N queens problem
- [ ] Sudoku Solver
- [ ] M coloring Problem
- [ ] Rat in a maze
- [ ] Word break (print all ways)

## BINARY SEARCH

- [ ] The Nth root of an Integer
- [ ] Matrix Median
- [ ] Find the element that appear once in a sorted array, and the rest element appears twice (Binary Search)
- [ ] Search element in a sorted and rotated array/find pivot where it is rotated
- [ ] Median of 2 sorted arrays
- [ ] Kth element of two sorted arrays
- [ ] Allocate Minimum Number of Pages
- [ ] Agressive Cows

## HEAPS

- [ ] Max Heap, Min Heap Implementation
- [ ] Kth Largest Element
- [ ] Maximum Sum Combination
- [ ] Find Median from Data Stream
- [ ] Merge k sorted arrays
- [ ] K most frequent elements

## STACK AND QUEUE Part 1

- [ ] Implement Stack Using Arrays
- [ ] Implement Queue Using Arrays
- [ ] Implement Stack Using Queue (Using single queue)
- [ ] Implement Queue Using Stack (O(1) amortized method)
- [ ] Check for balanced parentheses
- [ ] Next Greater Element
- [ ] Sort a Stack

## STACK AND QUEUE Part 2

- [ ] Next Smaller Element
- [ ] LRU cache (IMPORTANT)
- [ ] LFU Cache
- [ ] Largest rectangle in a histogram
- [ ] Sliding window maximum
- [ ] Implement Min Stack
- [ ] Rotten Orange (Using BFS)
- [ ] Stock Span Problem
- [ ] Find the maximum of minimums of every window size
- [ ] The celebrity problem

## STRING Part 1

- [ ] Reverse words in a string
- [ ] Longest Palindrome in a string
- [ ] Roman Number to Integer and vice versa
- [ ] Implement ATOI/STRSTR
- [ ] Longest Common Prefix
- [ ] Rabin Karp

## STRING Part 2

- [ ] Z - Function
- [ ] KMP algo / LPS(pi) array
- [ ] Minimum characters needed to be inserted in the beginning to make it palindromic
- [ ] Check for Anagrams
- [ ] Count and say
- [ ] Compare version numbers

## BINARY TREE Part 1

- [ ] Inorder Traversal
- [ ] Preorder Traversal
- [ ] Postorder Traversal
- [ ] Morris Inorder Traversal
- [ ] Morris Preorder Traversal
- [ ] LeftView of binary tree
- [ ] Bottom View of Binary Tree
- [ ] Top View of Binary Tree
- [ ] Preorder inorder postorder in a single traversal
- [ ] Vertical order traversal
- [ ] Root to node path in a Binary Tree
- [ ] Max width of a binary tree

## BINARY TREE Part 2

- [ ] Level Order traversal/Level order traversal in sprial form
- [ ] Height of a binary tree
- [ ] Diameter of binary tree
- [ ] Check if the binary tree is height-balanced or not
- [ ] LCA in binary tree
- [ ] Check if two trees are idenctical or not
- [ ] Zig Zag Traversal of Binary Tree
- [ ] Boundary Traversal of Binary Tree

## BINARY TREE Part 3

- [ ] Maximum path sum
- [ ] Construct Binary Tree from inorder and preorder
- [ ] Construct Binary Tree from inorder and postorder
- [ ] Symmetric Binary Tree
- [ ] Flatten Binary Tree of LinkedList
- [ ] Check if Binary Tree is the mirror of itself or not
- [ ] Check for children sum property

## BINARY SEARCH TREE Part 1

- [ ] Populate next right pointers of tree
- [ ] Search given key in BST
- [ ] Construct BST from given keys
- [ ] Construct BST from preorder traversal
- [ ] Check if a BT is BST or not
- [ ] Find LCA of two nodes in BST
- [ ] Find the inorder predecessor/successor of a given key in BST.  

## BINARY SEARCH TREE Part 2

- [ ] Floor in a BST
- [ ] Ceil in a BST
- [ ] Find kth smallest element in BST
- [ ] Find kth largest element in BST
- [ ] Find a pair with a given sum in BST
- [ ] BST iterator
- [ ] Size of the largest BST in a Binary Tree
- [ ] Serialize and deserialize Binary Tree

## BINARY TREES (Miscellaneous)

- [ ] Binary Tree to double linked list
- [ ] Find median in a stream of running integers.
- [ ] Kth largest element in a stream.
- [ ] Distinct numbers in window.
- [ ] Kth largest element in an unsorted array.
- [ ] Flood-fill Algorithm

## GRAPH Part 1

- [ ] Clone a graph
- [ ] DFS (Depth first search)
- [ ] BFS (Breadth first search)
- [ ] Detect a cycle in undirected graph using DFS
- [ ] Detect a cycle in undirected graph using BFS
- [ ] Topological Sort BFS
- [ ] Topological Sort DFS
- [ ] Number of Islands
- [ ] Bipartite check using BFS
- [ ] Bipartite check using DFS

## GRAPH Part 2

- [ ] Strongly Connected Component (using KosaRaju's algo)
- [ ] Dijkstra's algorithm
- [ ] Belman-ford algorithm
- [ ] Floyd-warshall algorithm
- [ ] MST using Prim's algo
- [ ] MST using Kruskal's algo

## Dynamic Programming Part 1

- [ ] Max Product Subarray
- [ ] Longest Increasing Subsequence
- [ ] Longest Common Subsequence
- [ ] 0-1 Knapsack
- [ ] Edit Distance
- [ ] Maximum sum increasing subsequence
- [ ] Matrix Chain Multiplication

## Dynamic Programming Part 2

- [ ] Minimum sum path in the matrix
- [ ] Coin change
- [ ] Subset Sum
- [ ] Rod Cutting
- [ ] Egg Dropping
- [ ] Word break
- [ ] Palindrome Partitioning (MCM Variation)
- [ ] Maximum profit in Job Scheduling

## Trie

- [ ] Implement Trie (Prefix Tree)
- [ ] Implement Trie - 2 (Prefix Tree)
- [ ] Longest String with all prefixes
- [ ] Number of distinct substrings in a string
- [ ] Power set (this is very important)
- [ ] Maximum XOR of two numbers in an array
- [ ] Maximum XOR with an Element from array